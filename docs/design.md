# Findings设计

## 基本功能

1. 提供各种类型节点的登记注册，向请求节点信息的客户端提供连系清单。
2. 为NAT内网节点提供NAT层级探测：`Pub/FullC` | `RC` | `P-RC` | `Sym`，即 STUN 服务。
3. 为任意类型P2P客户端提供 `UDP打洞` 协助（信令中介）。
4. 支持任意应用的TCP公网服务器登记，方便其应用的TCP连接。

通常，应用节点会启动一个自己的Findings服务器，该服务器连入Findings主网后，即可就近提供目标类型的节点信息。



## 节点类型

### 组网节点

构建Findings主网的节点称为组网节点，它们通常由可直接连入的 `Pub/FullC` 节点组成，但也支持NAT受限节点的*连入*。

组网节点之间采用安全的TCP协议连接。虽然P2P节点间没有信任，但安全连接可避免外部窥探和分析。


### 应用节点

应用节点是除了组网节点之外的所有类型的节点。它们连接Findings网络，申请NAT探测服务或UDP打洞协助。


### 节点信息

如下4个字段概括了节点的必要信息：

- 类型：depots:xx | blockchain:xx | app:xx | findings:xx
- 地址：IP:Port（公网可见）
- NAT： Pub/FullC | RC | P-RC | Sym
- 公钥：通常为一次性，启动后自动创建。主要用于密钥交换（ECDH）。

> **注：**
> 公钥主要用于节点间初始连接时加密传输自签名证书，进而创建安全连接。



## 节点组网

组网节点相互连接、协作，动态地交换信息，维持Findings网络的持续运行。


### 候选池

暂存一些可直接连入的 `Pub/FullC` 公网节点，当执行连接切换时，将从中随机抽取节点进行连接。

当与新的节点连接后，会彼此分享自己候选池的节点信息，完成动态的信息交换。**注**：分享的节点在合并前会测试其可连接性。

> **合并策略：**
> 低延迟优先，适当兼顾中高延迟节点，避免明显的地域分割。


### 组网池

即当前组网节点的连接池，负责Findings网络的维系：动态更新、扩散候选池成员、提供NAT探测服务等。

> **注：**
> NAT受限节点虽然不能接受连入，但协助NAT探测中的 `NewHost` 没有问题。


### 应用池

接受各类应用节点的连入、登记，提供同类或异类节点间的UDP打洞协助（中介信令）。

能提供打洞协助的Findings节点只能是公网节点，因为只有它们能直接接收其它应用节点的连入。打洞协助所支持的应用类型由节点自由配置。

> **注：**
> 位于NAT之后的Findings节点也可以作为应用申请NAT探测和打洞服务。


### 分享池

对于支持TCP直连服务器的应用，其服务器节点可以登记到分享池。这样，该应用类型的客户端就可以很容易地连接到其服务器了。



## 连接安全

节点间的TCP连接采用安全的websocket协议（`wss://`），但这需要证书。P2P节点并不关心对方是否可信，因此这里采用**自签名**证书。

> **注：**
> 自签名证书通常是一次性的，仅限于当前会话或当前运行期内。

自签名证书需要传递到对端，让对端设置信任，才能创建安全的TLS连接。这需要一个特别的初始连接流程，如下：


### 公网节点之间

新上线的节点接入Findings网络，通过上线协助请求，获取组网节点信息，其中包含地址和公钥。

> **上线协助：**
> 客户端连接Findings节点后，单次请求组网节点信息，然后即断开连接。

之后与组网节点的正式连接遵循如下流程：

0. 客户端已启动一个含自签名证书的服务监听，常驻运行。

1. 客户端连接服务端，忽略服务端的自签名证书验证。建立初次连接（不可靠）。
2. 客户端用服务器的公钥计算共享密钥，加密自己的自签名证书和服务端口（会用到一个Nonce）。
3. 客户端将密文和自己的公钥明文（以及Nonce）发送给服务器。
4. 服务器获取客户端公钥，计算共享密钥，结合Nonce解密自签名证书和服务端口。

5. 服务器变身为客户端，设置信任该自签名证书，向对端（原客户端）发起连接。
6. 原客户端此时即为服务器，接受连接。至此创建正常的安全连接。

这里有一个角色切换，限制了双方都必须为公网节点（这正是目的）。


### 从NAT内网发起的连接

受限节点对公网节点的连接没有角色切换，采用如下流程：

1. 客户端连接服务器，忽略服务器端自签名证书的验证。建立首次连接（不可靠）。
2. 客户端用服务器的公钥创建共享密钥，加密一个会话标识（会用到一个Nonce）。
3. 客户端打包密文、自己的公钥明文（以及Nonce）传递给服务器。
4. 服务器用客户端的公钥创建共享密钥，结合Nonce解密会话标识。
5. 服务器打包自己的自签名证书和客户端会话标识，加密传递给客户端。
6. 客户端解密证书和会话标识，会话标识验证当次会话。
7. 客户端设置该自签名证书可信，重新连接服务器。至此创建正常的安全连接。


### 公钥广播与验证

组网节点在接收分享来的节点信息时，除了连接测试外，还应当对其公钥进行验证。

验证可采用很简单的方式：

- 连接目标节点，用共享密钥加密一个标识，连同自己的公钥明文一并发送。
- 对端解密获取消息内容，加密发送一个回应（标识 + 自身地址）。
- 本端解密回应消息，核实标识（以及地址），证实公钥真实性。完成验证。



## 杂项

### 服务器群

服务节点会向应用提供自己的区块链地址，用于接收可能有的收益分成或捐赠。

在区块链对公共服务的激励机制中，服务节点需要对区块链铸造者可见并且被认可。所以一个足够规模且服务良好的服务器群是有意义的。

服务器群并不需要是一个真正物理连接的集群。只要服务节点提供一个相同的收益地址，它们在收益逻辑上就是一个群。

为便于区分服务器群里的各个成员，可以用一个**身份ID**来标识具体的服务节点，以便于服务器群里各成员的考评区分。

这是一种离散且自由的组织机制。当然，一个真实的物理集群也适用此机制。


### 动态端口算法

加入工作量机制的随机动态端口更强壮。代码示意如下：

```go
// App配置项：
// 在App发布时配置，连接各方此值相同。
var timeFrom   time.Time = GetConfig("timeFrom")    // 起始时间
var randBase    int64    = GetConfig("randBase")    // 随机种子
var diffValue  [32]byte  = GetConfig("diffValue")   // 难度目标（前置零越多越难）

// 参与计算的因子（动态）
var IP netip.AddrPort   // 服务器地址
var hours int64         // 起始时间到当前时间的距离
var portRnd int64       // 端口随机数

// 确定性随机
rand.Seed( randBase )

// 随机值上界
const randMax = 1<<63 - 1

// 工作量循环
for {
    // 单小时确定
    hours = time.Since(timeFrom) % time.Hour
    portRnd = rand.Intn(randMax)

    // 串联计算哈希
    tmp := sha256.Sum256( IP + hours + portRnd )

    if tmp < diffValue {
        break // 满足目标难度
    }
}
// 最终端口
return (portRnd % 64511) + 1024
```

备用端口：目标端口 `+1` 和 `+2`。例：计算端口 `6688`，则备用端口 `6689` 和 `6690`。
